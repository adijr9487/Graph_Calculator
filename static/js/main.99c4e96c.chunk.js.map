{"version":3,"sources":["Components/Canvas/Draw/Grid.js","Components/Canvas/Draw/Plane.js","Components/Canvas/Graph.js","Components/Graph.js","App.js","index.js","Components/Graph.css"],"names":["MAKE_GRID","ctx","canvas","GRAPH_DATA","screenOrigin","fillStyle","rect","width","height","fill","DRAW_GRID","initialX","Math","floor","x","initialY","y","scanning","center","printing","minor_space","from","to","gridType","major_space","value","SHOW_TEXT","label_font_size","MAKE_LINE","abs","newPositionY","length","text","fontSize","font","fillText","beginPath","strokeStyle","lineWidth","moveTo","lineTo","stroke","closePath","SHOW_PLANE","space","mini_graph_scale","MAKE_PLANE","makeRect","drawGrid","margin","rect_TOP_LEFT","shadowColor","shadowBlur","AnimationID","undefined","CTX","CANVAS","SCREEN_ORIGIN_POSITION","WHEN_MOUSE_DOWN_SCREEN_POSITION","MOUSE_DOWN","scale","setOrigin","Origin","getStandardCord","position","invertStandardCord","renderGraph","requestAnimationFrame","clearRect","clickHandler","e","mouseMoveHandler","event","isTouched","preventDefault","delta","SCREEN_POSITION","NEW_SCREEN_POSITION","mouseDownHandler","mouseUpHandler","Graph","props","CanvasRef","useRef","ContextRef","useState","useEffect","current","getContext","offsetHeight","offsetWidth","window","addEventListener","resizeHandler","changedTouches","clientX","clientY","console","log","cancelAnimationFrame","className","classes","baseDIV","Canvas","ref","App","ReactDOM","render","StrictMode","document","getElementById","module","exports"],"mappings":"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","file":"static/js/main.99c4e96c.chunk.js","sourcesContent":["export const MAKE_GRID = (ctx, canvas, GRAPH_DATA, screenOrigin) => {\r\n  //setting background\r\n\r\n  // console.log(screenOrigin)\r\n  ctx.fillStyle = \"#393939\";\r\n  ctx.rect(0, 0, canvas.width, canvas.height);\r\n  ctx.fill();\r\n  DRAW_GRID(ctx, canvas, screenOrigin, GRAPH_DATA);\r\n  // MAKE_LINE(ctx, canvas)\r\n};\r\n\r\n//we have assume that graph exist somewhere and we are projecting a cross-section of that graph on our screen\r\nconst DRAW_GRID = (ctx, canvas, screenOrigin, GRAPH_DATA) => {\r\n  //if axis lie outside the screen\r\n\r\n  let initialX = Math.floor(screenOrigin.x - canvas.width / 2);\r\n  let initialY = Math.floor(screenOrigin.y - canvas.height / 2);\r\n\r\n  //scanning the graph before printing it on the screen\r\n  let scanning = {\r\n    x: initialX,\r\n    y: initialY,\r\n  };\r\n\r\n  // origin (0, 0) of graph with respect to screen initial point\r\n  let center = {\r\n    x: -initialX,\r\n    y: -initialY,\r\n  };\r\n\r\n  //printing coordinate after scanning it from mathematical graph plane\r\n  let printing = {\r\n    x: 0,\r\n    y: 0,\r\n  };\r\n\r\n  //draw verticle grid line (scanning)\r\n  while (scanning.x < screenOrigin.x + canvas.width / 2) {\r\n    if (scanning.x % GRAPH_DATA.minor_space === 0) {\r\n      //if this point is a grid line\r\n      let from = {\r\n        x: printing.x,\r\n        y: printing.y,\r\n      };\r\n      let to = {\r\n        x: printing.x,\r\n        y: printing.y + canvas.height,\r\n      };\r\n      // here major and axis is verticle line\r\n      let isAxis = scanning.x === 0;\r\n      let gridType = \"minor\";\r\n      if (scanning.x === 0) {\r\n        gridType = \"axis\";\r\n      } else if (scanning.x % GRAPH_DATA.major_space === 0) {\r\n        gridType = \"major\";\r\n      }\r\n\r\n      if (gridType === \"axis\" || gridType === \"major\") {\r\n        //here major and axis is verticle line\r\n        let value = (printing.x - center.x) / GRAPH_DATA.major_space;\r\n        SHOW_TEXT(\r\n          ctx,\r\n          value,\r\n          GRAPH_DATA.label_font_size,\r\n          printing.x + 5,\r\n          center.y + 20\r\n        );\r\n      }\r\n\r\n      MAKE_LINE(ctx, canvas, from, to, gridType);\r\n    } else if (initialX % GRAPH_DATA.minor_space !== 0) {\r\n      //if this point is not a grid line\r\n    }\r\n    printing.x++;\r\n    scanning.x++;\r\n  }\r\n\r\n  //checking if the verticle axis is inside the screen\r\n  if (Math.abs(screenOrigin.x) > canvas.width / 2) {\r\n    if (screenOrigin.x < 0) printing.x = printing.x;\r\n    else if (screenOrigin.x > 0) printing.x = 10;\r\n    //here(inside if) y axis is outside the screen\r\n\r\n    //using while loop for horizontal grid line (to lable point on the line outside the screen)\r\n\r\n    while (scanning.y < screenOrigin.y + canvas.height / 2) {\r\n      if (scanning.y % GRAPH_DATA.major_space === 0) {\r\n        let value = (center.y - printing.y) / GRAPH_DATA.major_space; //center is the center of screen // printing is the position with respect to the screen\r\n        if (value != 0) {\r\n          let newPositionY = printing.x;\r\n          if (screenOrigin.x < 0) {\r\n            // this is used to adjust the right margin(part) of screen to display label/\r\n            newPositionY =\r\n              newPositionY -\r\n              GRAPH_DATA.label_font_size * (value + \"\").length +\r\n              (value + \"\").length;\r\n          }\r\n          SHOW_TEXT(\r\n            ctx,\r\n            value,\r\n            GRAPH_DATA.label_font_size,\r\n            newPositionY,\r\n            printing.y - 5\r\n          );\r\n        }\r\n\r\n        // this is use so that we dont have to iterate for each point just to lable the number line\r\n        //after finding first label we will just with space of major_space\r\n        printing.y += GRAPH_DATA.major_space;\r\n        scanning.y += GRAPH_DATA.major_space;\r\n      } else {\r\n        printing.y++;\r\n        scanning.y++;\r\n      }\r\n    }\r\n  }\r\n\r\n  scanning.x = initialX;\r\n  scanning.y = initialY;\r\n\r\n  // reseting value of printing to intial\r\n  printing = {\r\n    x: 0,\r\n    y: 0,\r\n  };\r\n  //draw horizontal grid line\r\n  while (scanning.y < screenOrigin.y + canvas.height / 2) {\r\n    if (scanning.y % GRAPH_DATA.minor_space === 0) {\r\n      //if this point is a grid line\r\n      let from = {\r\n        x: printing.x,\r\n        y: printing.y,\r\n      };\r\n      let to = {\r\n        x: printing.x + canvas.width,\r\n        y: printing.y,\r\n      };\r\n      let gridType = \"minor\";\r\n      if (scanning.y === 0) {\r\n        //if the grid line is axis\r\n        gridType = \"axis\";\r\n      } else if (scanning.y % GRAPH_DATA.major_space === 0) {\r\n        // if the grid line is a major line(second most thick line)\r\n        gridType = \"major\";\r\n      }\r\n      // console.log(\"Hello\")\r\n      MAKE_LINE(ctx, canvas, from, to, gridType);\r\n\r\n      if (gridType === \"axis\" || gridType === \"major\") {\r\n        //if grid line is axis or major\r\n        let value = (center.y - printing.y) / GRAPH_DATA.major_space; //center is the center of screen // printing is the position with respect to the screen\r\n        if (value != 0)\r\n          SHOW_TEXT(\r\n            ctx,\r\n            value,\r\n            GRAPH_DATA.label_font_size,\r\n            center.x + 5,\r\n            printing.y - 5\r\n          );\r\n      }\r\n    } else if (initialY % GRAPH_DATA.minor_space !== 0) {\r\n      //if this point is not a grid line\r\n    }\r\n    printing.y++;\r\n    scanning.y++;\r\n  }\r\n\r\n  //checking if the horizontal axis is inside the screen\r\n  if (Math.abs(screenOrigin.y) > canvas.height / 2) {\r\n    if (screenOrigin.y < 0) printing.y = printing.y - 10;\r\n    else if (screenOrigin.y > 0) printing.y = 20;\r\n    // console.log(\"Outside\")\r\n    //here(inside if) x axis is outside the screen\r\n\r\n    //using while loop for horizontal grid line\r\n    while (scanning.x < screenOrigin.x + canvas.width / 2) {\r\n      if (scanning.x % GRAPH_DATA.major_space === 0) {\r\n        //if this point is a grid line\r\n        let value = (printing.x - center.x) / GRAPH_DATA.major_space;\r\n        if (value != 0)\r\n          SHOW_TEXT(\r\n            ctx,\r\n            value,\r\n            GRAPH_DATA.label_font_size,\r\n            printing.x + 5,\r\n            printing.y\r\n          );\r\n\r\n        printing.x += GRAPH_DATA.major_space;\r\n        scanning.x += GRAPH_DATA.major_space;\r\n      } else {\r\n        printing.x++;\r\n        scanning.x++;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nconst SHOW_TEXT = (ctx, text, fontSize, x, y) => {\r\n  ctx.font = fontSize + \"px Arial\";\r\n  ctx.fillStyle = \"#ffffff\";\r\n  ctx.fillText(text, x, y);\r\n};\r\n\r\nconst MAKE_LINE = (ctx, canvas, from, to, gridType) => {\r\n  ctx.beginPath();\r\n  // console.log(from, to)\r\n  ctx.strokeStyle = \"#989898\";\r\n\r\n  if (gridType === \"axis\") ctx.lineWidth = 3;\r\n  else if (gridType === \"major\") ctx.lineWidth = 1;\r\n  else if (gridType === \"minor\") ctx.lineWidth = 0.1;\r\n\r\n  ctx.moveTo(from.x, from.y);\r\n  ctx.lineTo(to.x, to.y);\r\n\r\n  ctx.stroke();\r\n  ctx.fill();\r\n\r\n  ctx.closePath();\r\n};\r\n","export const SHOW_PLANE = (ctx, canvas, GRAPH_DATA, screenOrigin) => {\r\n\r\n    let miniScale = GRAPH_DATA.space*GRAPH_DATA.mini_graph_scale;\r\n\r\n    MAKE_PLANE(ctx, canvas)\r\n\r\n} \r\n\r\nconst MAKE_PLANE = (ctx, canvas) => {\r\n\r\n    let margin = 20\r\n    let height = canvas.height*0.20 * 2\r\n    let width = canvas.width*0.20\r\n\r\n    makeRect(ctx, canvas, margin, height, width);\r\n    drawGrid(ctx, canvas, margin, height, width);\r\n}\r\n\r\nconst makeRect = (ctx, canvas, margin, height, width) => {\r\n    \r\n    let rect_TOP_LEFT = {\r\n        x: canvas.width - margin - width,\r\n        y: canvas.height - margin - height,\r\n    }\r\n\r\n    ctx.beginPath();\r\n    ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';\r\n    ctx.shadowBlur = 30;\r\n    ctx.lineWidth = 1;\r\n    ctx.fillStyle = \"#393939\";\r\n    ctx.strokeStyle = \"#727272\";\r\n    ctx.rect(rect_TOP_LEFT.x, rect_TOP_LEFT.y, width, height)\r\n    ctx.fill();\r\n    ctx.stroke();\r\n    ctx.closePath();\r\n\r\n}\r\n\r\nconst drawGrid = (ctx, canvas, margin, height, width) => {\r\n    \r\n    let rect_TOP_LEFT = {\r\n        x: canvas.width - margin - width,\r\n        y: canvas.height - margin - height,\r\n    }\r\n\r\n    // while(scanning.x < screenOrigin.x + canvas.width/2){\r\n\r\n    //     if(scanning.x % space === 0){\r\n    //         //if this point is a grid line\r\n    //         let from = {\r\n    //             x: printing.x,\r\n    //             y: printing.y\r\n    //         }\r\n    //         let to = {\r\n    //             x: printing.x,\r\n    //             y: printing.y+canvas.height\r\n    //         }\r\n    //         let isAxis = (scanning.x === 0);\r\n    //         MAKE_LINE(ctx, canvas, from, to, isAxis)\r\n    //     }\r\n    //     else if(initialX % space !== 0){\r\n    //         //if this point is not a grid line\r\n    //     }\r\n    //     printing.x++;\r\n    //     scanning.x++;\r\n    // }\r\n\r\n    // scanning.x = initialX\r\n    // scanning.y = initialY\r\n\r\n    // printing = {\r\n    //     x: 0,\r\n    //     y: 0,\r\n    // }\r\n    // //draw horizontal grid line\r\n    // while(scanning.y < screenOrigin.y + canvas.height/2){\r\n\r\n    //     if(scanning.y % space === 0){\r\n    //         //if this point is a grid line\r\n    //         let from = {\r\n    //             x: printing.x,\r\n    //             y: printing.y\r\n    //         }\r\n    //         let to = {\r\n    //             x: printing.x+canvas.width,\r\n    //             y: printing.y\r\n    //         }\r\n    //         let isAxis = (scanning.y === 0);\r\n    //         MAKE_LINE(ctx, canvas, from, to , isAxis)\r\n            \r\n    //     } else if(initialY % space !== 0){\r\n    //         //if this point is not a grid line\r\n    //     }\r\n    //     printing.y++;\r\n    //     scanning.y++;\r\n    // }\r\n\r\n}\r\n\r\nconst makeLine = (ctx, canvas, from, to) => {\r\n    ctx.beginPath();\r\n\r\n    ctx.strokeStyle = \"#727272\";\r\n    ctx.lineWidth = 2;\r\n\r\n    ctx.moveTo(from.x, from.y)\r\n    ctx.lineTo(to.x, to.y)\r\n\r\n    ctx.stroke();\r\n    ctx.fill();\r\n    ctx.closePath();\r\n}","import {MAKE_GRID} from \"./Draw/Grid\"\r\nimport {SHOW_PLANE} from \"./Draw/Plane\"\r\n\r\n//Canas variable\r\nlet AnimationID = undefined\r\nlet CTX = undefined\r\nlet CANVAS = undefined \r\n\r\n//position\r\nlet SCREEN_ORIGIN_POSITION = undefined\r\nlet WHEN_MOUSE_DOWN_SCREEN_POSITION = undefined\r\n\r\n//mouse vairable\r\nlet MOUSE_DOWN = undefined;\r\n\r\n//GRAPH varible\r\nlet GRAPH_DATA = {\r\n    minor_space: 10,\r\n    major_space: 100, \r\n    scale: 1,\r\n    mini_graph_scale: 0.2, \r\n    label_font_size: 15,\r\n}\r\n//This function will run after the Graph React component is rendered;\r\nexport const setContextAndCanvas = (ctx, canvas) => {\r\n    CTX = ctx\r\n    CANVAS = canvas\r\n\r\n}\r\n\r\nexport const initializeVariables = () => {\r\n\r\n    setOrigin();\r\n}\r\n\r\nconst setOrigin = (Origin) => {\r\n    if (!Origin){\r\n        SCREEN_ORIGIN_POSITION = {x: 0, y: 0}\r\n    }else{\r\n        SCREEN_ORIGIN_POSITION = getStandardCord(Origin)\r\n    }\r\n}\r\n\r\nconst getStandardCord = (position) => {\r\n    let newStandardOrigin = {   \r\n        x: position.x,\r\n        y: -position.y,\r\n    }\r\n    return newStandardOrigin;\r\n}\r\n\r\nconst invertStandardCord = (position) => {\r\n    let newStandardOrigin = {   \r\n        x: position.x,\r\n        y: -position.y,\r\n    }\r\n    return newStandardOrigin;\r\n}\r\n\r\nexport const initializeAllEventListener = () => {\r\n    CANVAS.addEventListener(\"click\", clickHandler)\r\n    CANVAS.addEventListener(\"mousemove\", mouseMoveHandler)\r\n    CANVAS.addEventListener(\"mousedown\", mouseDownHandler)\r\n    CANVAS.addEventListener(\"mouseup\", mouseUpHandler)\r\n    CANVAS.addEventListener(\"mouseleave\", mouseUpHandler)\r\n\r\n    // passing second argument as event (to set event.preventDefault (as first argument is no more (((event)))  )) and third argument true (to recognise when it is touched)\r\n    CANVAS.addEventListener(\"touchstart\", (e) => mouseDownHandler({x:e.changedTouches[0].clientX, y:e.changedTouches[0].clientY}, e, true))\r\n    CANVAS.addEventListener(\"touchmove\", (e) => mouseMoveHandler({x:e.changedTouches[0].clientX, y:e.changedTouches[0].clientY}, e, true))\r\n    CANVAS.addEventListener(\"touchend\", (e) => mouseUpHandler({x:e.changedTouches[0].clientX, y:e.changedTouches[0].clientY}, e, true))\r\n    CANVAS.addEventListener(\"touchcancel\", (e) => mouseUpHandler({x:e.changedTouches[0].clientX, y:e.changedTouches[0].clientY}, e, true))\r\n}\r\n\r\nexport const renderGraph =() => {\r\n    AnimationID = requestAnimationFrame(renderGraph);\r\n\r\n    //clear rect\r\n    CTX.clearRect(0, 0, CANVAS.width, CANVAS.height)\r\n\r\n    //setting grid\r\n    // console.log(WHEN_MOUSE_DOWN_SCREEN_POSITION)\r\n\r\n    if(WHEN_MOUSE_DOWN_SCREEN_POSITION){\r\n        MAKE_GRID(CTX, CANVAS, GRAPH_DATA, WHEN_MOUSE_DOWN_SCREEN_POSITION);\r\n        SHOW_PLANE(CTX, CANVAS, GRAPH_DATA, SCREEN_ORIGIN_POSITION);\r\n    }\r\n    else{    \r\n        MAKE_GRID(CTX, CANVAS, GRAPH_DATA, SCREEN_ORIGIN_POSITION);\r\n        SHOW_PLANE(CTX, CANVAS, GRAPH_DATA, SCREEN_ORIGIN_POSITION);\r\n    }\r\n\r\n}\r\n\r\nconst clickHandler = (e) => {\r\n}\r\n\r\nconst mouseMoveHandler = (e, event, isTouched) => {\r\n    if(isTouched){\r\n        event.preventDefault();\r\n    }\r\n    if(MOUSE_DOWN !== undefined){\r\n        let delta = ({\r\n            x: MOUSE_DOWN.x - e.x,\r\n            y: e.y - MOUSE_DOWN.y ,\r\n        })\r\n        let SCREEN_POSITION = invertStandardCord(SCREEN_ORIGIN_POSITION)\r\n\r\n        let NEW_SCREEN_POSITION = {\r\n            x: delta.x + SCREEN_POSITION.x,\r\n            y: delta.y + SCREEN_POSITION.y\r\n        }\r\n        // console.log(SCREEN_POSITION)\r\n        WHEN_MOUSE_DOWN_SCREEN_POSITION = getStandardCord(NEW_SCREEN_POSITION)\r\n\r\n    }\r\n}\r\nconst mouseDownHandler = (e, event, isTouched) => {\r\n    if(isTouched){\r\n        event.preventDefault();\r\n    }\r\n    MOUSE_DOWN = {\r\n        x: e.x,\r\n        y: e.y,\r\n    }\r\n}\r\nconst mouseUpHandler = (e, event, isTouched) => {\r\n    if(isTouched){\r\n        event.preventDefault();\r\n    }\r\n    // console.log(SCREEN_ORIGIN_POSITION)\r\n    \r\n    if(MOUSE_DOWN !== undefined){\r\n        let delta = ({\r\n            x: MOUSE_DOWN.x - e.x,\r\n            y: e.y - MOUSE_DOWN.y ,\r\n        })\r\n        let SCREEN_POSITION = invertStandardCord(SCREEN_ORIGIN_POSITION)\r\n        \r\n        let NEW_SCREEN_POSITION = {\r\n            x: delta.x + SCREEN_POSITION.x,\r\n            y: delta.y + SCREEN_POSITION.y\r\n        }\r\n        setOrigin(NEW_SCREEN_POSITION)\r\n    }\r\n\r\n    MOUSE_DOWN = undefined;\r\n    WHEN_MOUSE_DOWN_SCREEN_POSITION = undefined\r\n}\r\n\r\n\r\nexport const cleanUpFunction = () => {\r\n\r\n    console.log(\"Clean Up function executed successfully\")\r\n    console.log(\"All eventListener Removed\")\r\n    //deleting clearing Animation Request\r\n    cancelAnimationFrame(AnimationID);\r\n}","import React, {useRef, useEffect, useState} from 'react'\r\n\r\n//component\r\n\r\n//classes\r\nimport classes from \"./Graph.css\"\r\n\r\n//functions\r\nimport {setContextAndCanvas, renderGraph, cleanUpFunction, initializeAllEventListener, initializeVariables} from \"./Canvas/Graph\"\r\n\r\nconst Graph = (props) => {\r\n\r\n    const CanvasRef = useRef(null);\r\n    const ContextRef = useRef(null);\r\n    //useState\r\n    const [Dimension, setDimension] = useState(null)\r\n\r\n                \r\n    useEffect(()=>{\r\n        ContextRef.current = CanvasRef.current.getContext('2d');\r\n        \r\n        CanvasRef.current.height = CanvasRef.current.offsetHeight;\r\n        CanvasRef.current.width = CanvasRef.current.offsetWidth;\r\n\r\n        window.addEventListener(\"resize\", resizeHandler)\r\n        setContextAndCanvas(ContextRef.current, CanvasRef.current)\r\n        initializeAllEventListener();\r\n        initializeVariables();\r\n\r\n        renderGraph();\r\n        \r\n        return()=>{\r\n            //packing up function ,, clearing eventListeners ,, \r\n            cleanUpFunction();\r\n        }\r\n\r\n    }, [])\r\n\r\n    // useEffect for refresh each frames\r\n\r\n    const resizeHandler = (e) => {\r\n        CanvasRef.current.height = CanvasRef.current.offsetHeight;\r\n        CanvasRef.current.width = CanvasRef.current.offsetWidth;\r\n\r\n    }\r\n\r\n    return (\r\n        <div className={classes.baseDIV}>\r\n            <canvas className={classes.Canvas} ref={CanvasRef} />\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Graph\r\n","import React from \"react\"\n\n//component\nimport Graph from \"./Components/Graph\"\n\n//classes\n\nfunction App() {\n  return (\n      <Graph />\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Canvas\":\"_2ZljSGwcOKumJLg2-dkZru\",\"baseDIV\":\"MjW4ixqkAOg5rGaY4LPzV\"};"],"sourceRoot":""}